#ifndef ORAX_ENUMS_H
#define ORAX_ENUMS_H

enum OperandType {
  OPTYPE_BYTE,
  OPTYPE_UBYTE,
  OPTYPE_HALF,
  OPTYPE_UHALF,
  OPTYPE_DOUBLE,
  OPTYPE_UDOUBLE,
  OPTYPE_QUAD,
  OPTYPE_UQUAD,
  OPTYPE_FLOAT,
  OPTYPE_DOUBLE_FLOAT,
  OPTYPE_TRIPLE_FLOAT,
  OPTYPE_POINTER,
  OPTYPE_STRING,
  OPTYPE_BOOLEAN,
};

enum InstructionClass {
  INSTCLASS_ARITHMETIC,
  INSTCLASS_RATIONAL,
  INSTCLASS_BITWISE,
  INSTCLASS_JUMPS,
  INSTCLASS_MEMORY_ACCESS,
  INSTCLASS_CALL_INTERFACE,
  INSTCLASS_SSA,
  INSTCLASS_EXTEND,
  INSTCLASS_TRUNCATE,
  INSTCLASS_VARARGS,
  INSTCLASS_ASSEMBLY_LITERAL,
  INSTCLASS_CONTROL_FLOW,
  INSTCLASS_DATA,
};

enum InstructionName {
  // Arithmetic
  INST_ADD,
  INST_SUBTRACT,
  INST_MULTIPLY,
  INST_UNSIGNED_MULTIPLY,
  INST_INTEGER_DIVIDE,
  INST_RATIOAL_DIVIDE,
  INST_UNSIGNED_DIVIDE,
  INST_MODULO,
  INST_UNSIGNED_MODULO,
  INST_REMAINDER,
  INST_UNSIGNED_REMAINDER,
  INST_EXPONENTIATE,

  // Relational
  INST_GREATER_THAN,
  INST_GREATER_THAN_EQUAL,
  INST_LESS_THAN,
  INST_LESS_THAN_EQUAL,
  INST_EQUALS,
  INST_NOT_EQUALS,

  // Bitwise
  INST_BITWISE_AND,
  INST_BITWISE_OR,
  INST_BITWISE_XOR,

  // Jumps
  INST_JUMP,
  INST_JUMP_IF_ZERO,
  INST_JUMP_IF_NOT_ZERO,

  // Memory Access
  INST_LOAD,
  INST_STORE,
  INST_LOAD_IF_ZERO,
  INST_LOAD_IF_NOT_ZERO,
  INST_STORE_IF_ZERO,
  INST_STORE_IF_NOT_ZERO,
  INST_LOAD_IF_GE,
  INST_LOAD_IF_GT,
  INST_STORE_IF_GE,
  INST_STORE_IF_GT,
  INST_LOAD_IF_LE,
  INST_LOAD_IF_LT,
  INST_STORE_IF_LE,
  INST_STORE_IF_LT,
  INST_LOAD_IF_EQ,
  INST_LOAF_IF_NE,
  INST_STORE_IF_EQ,
  INST_STORE_IF_NE,
  INST_ALLOC_STACK,

  // Call Interface
  INST_CALL,
  INST_CALL_IF_ZERO,
  INST_CALL_IF_NOT_ZERO,
  INST_CALL_IF_GT,
  INST_CALL_IF_GE,
  INST_CALL_IF_LT,
  INST_CALL_IF_LE,
  INST_CALL_IF_EQ,
  INST_CALL_IF_NE,

  // SSA
  INST_PHI,

  // Extend
  INST_EXTEND_ONE_BYTE,
  INST_EXTEND_TWO_BYTES,
  INST_EXTEND_THREE_BYTES,

  // Truncate
  INST_TRUNC_ONE_BYTE,
  INST_TRUNC_TWO_BYTES,
  INST_TRUNC_THREE_BYTES,

  // Variable Arguments
  INST_VARARG_START,
  INST_VARARG,

  // Assembly
  INST_ASSEMBLY_LITERAL,

  // Control Flow
  INST_HALT,
  INST_RETURNi,

  // Data
  INST_CAST_DATA,
  INST_COPY_DATA,
  INST_LITERAL_DATA,
};

enum SExpressionType {
  SEXP_ATOM,
  SEXP_LIST,
  SEXP_SYNOBJ,
};

enum SemanticItemType {
  SEMITEM_TERMINAL,
  SEMITEM_NONTERMINAL,
};

enum TypeKind {
  BASEWORD,
  COMPLEX,
};

enum TypeStaticity {
  TYPE_STATIC_EXPLICIT,
  TYPE_STATIC_IMPLICIT,
  TYPE_DYNAMIC_TAGGED,
  TYPE_DYNAMIC_UNTAGGED,
};

enum TypeStrength {
  TYPE_STRONG,
  TYPE_WEAK,
};

enum BaseWordType {
  BASEWORD_I8,
  BASEWORD_U8,
  BASEWORD_I16,
  BASEWORD_U16,
  BASEWORD_I32,
  BASEWORD_U32,
  BASEWORD_I64,
  BASEWORD_U64,
};

#endif
